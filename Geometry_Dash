import pygame, random, sys, os, json
import socket
import threading
import pickle
import time

# ================= INIT =================
pygame.init()
WIDTH, HEIGHT = 1000, 600
FPS = 60

# ================= NETWORK SETTINGS =================
HOST = "0.0.0.0"
PORT = 5555
BUFFER_SIZE = 65536  # Nagyobb buffer → kevesebb fragmentáció

# ================= SETTINGS FILE =================
SETTINGS_FILE = "settings.json"

def load_settings():
    default_settings = {
        "fullscreen": True,
        "music_volume": 0.5,
        "sfx_volume": 0.5,
        "skin_index": 0
    }
    try:
        with open(SETTINGS_FILE, "r") as f:
            settings = json.load(f)
            for key in default_settings:
                if key not in settings:
                    settings[key] = default_settings[key]
            return settings
    except:
        return default_settings

def save_settings(settings):
    try:
        with open(SETTINGS_FILE, "w") as f:
            json.dump(settings, f, indent=4)
    except:
        pass

settings = load_settings()
fullscreen_enabled = settings["fullscreen"]
music_volume = settings["music_volume"]
sfx_volume = settings["sfx_volume"]
skin_index = settings["skin_index"]

# ================= FULLSCREEN SETTING =================
if fullscreen_enabled:
    screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
    WIDTH, HEIGHT = screen.get_size()
else:
    screen = pygame.display.set_mode((WIDTH, HEIGHT))

pygame.display.set_caption("Geometry Dash PRO")
clock = pygame.time.Clock()

# ================= COLORS =================
WHITE=(255,255,255); BLACK=(0,0,0); BLUE=(0,150,255)
RED=(255,50,50); GREEN=(50,255,50); PURPLE=(200,50,255)
YELLOW=(255,255,0); GRAY=(100,100,100); ORANGE=(255,165,0)
CYAN=(0,255,255); PINK=(255,105,180)

# ================= SETTINGS =================
GROUND_Y = HEIGHT - 100
GRAVITY = 0.6
JUMP = -13
BASE_SPEED = 7
MAX_SPEED = 15
SPEED_INCREASE_RATE = 0.05

# ================= HIGHSCORE & MAX SPEED FILE =================
SCORES_FILE = "scores.json"

def load_scores():
    default_scores = {"high_score": 0, "max_speed": BASE_SPEED}
    try:
        with open(SCORES_FILE, "r") as f:
            return json.load(f)
    except:
        return default_scores

def save_scores(hs, ms):
    try:
        with open(SCORES_FILE, "w") as f:
            json.dump({"high_score": hs, "max_speed": ms}, f, indent=4)
    except:
        pass

scores = load_scores()
high_score = scores["high_score"]
max_speed_record = scores["max_speed"]

# ================= PLAYER SKINS =================
SKINS = [
    (0,150,255),(255,255,0),(255,0,255),(0,255,255),(255,0,0),(0,255,0)
]

# ================= PARALLAX BG =================
stars = [[random.randint(0,WIDTH), random.randint(0,HEIGHT), random.randint(1,3)] for _ in range(200)]

# ================= SOUND EFFECTS =================
jump_sound = None
death_sound = None
score_sound = None

def load_sounds():
    global jump_sound, death_sound, score_sound
    try:
        jump_sound = pygame.mixer.Sound("jump.wav")
        jump_sound.set_volume(sfx_volume)
    except: jump_sound = None
    try:
        death_sound = pygame.mixer.Sound("death.wav")
        death_sound.set_volume(sfx_volume)
    except: death_sound = None
    try:
        score_sound = pygame.mixer.Sound("score.wav")
        score_sound.set_volume(sfx_volume)
    except: score_sound = None

def update_sfx_volume():
    if jump_sound: jump_sound.set_volume(sfx_volume)
    if death_sound: death_sound.set_volume(sfx_volume)
    if score_sound: score_sound.set_volume(sfx_volume)

def play_jump_sound():
    if jump_sound: jump_sound.play()
def play_death_sound():
    if death_sound: death_sound.play()
def play_score_sound():
    if score_sound: score_sound.play()

load_sounds()

# ================= MUSIC CONTROL =================
def play_menu_music():
    try:
        pygame.mixer.music.load("menumusic.mp3")
        pygame.mixer.music.set_volume(music_volume)
        pygame.mixer.music.play(-1)
    except: pass

def play_game_music():
    try:
        pygame.mixer.music.load("background.mp3")
        pygame.mixer.music.set_volume(music_volume)
        pygame.mixer.music.play(-1)
    except: pass

def update_music_volume():
    pygame.mixer.music.set_volume(music_volume)

def toggle_fullscreen():
    global screen, WIDTH, HEIGHT, fullscreen_enabled, GROUND_Y
    fullscreen_enabled = not fullscreen_enabled
    if fullscreen_enabled:
        screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
        WIDTH, HEIGHT = screen.get_size()
    else:
        WIDTH, HEIGHT = 1000, 600
        screen = pygame.display.set_mode((WIDTH, HEIGHT))
    GROUND_Y = HEIGHT - 100
    save_current_settings()

def save_current_settings():
    save_settings({
        "fullscreen": fullscreen_enabled,
        "music_volume": music_volume,
        "sfx_volume": sfx_volume,
        "skin_index": skin_index
    })

def get_local_ip():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
        s.close()
        return ip
    except:
        return "127.0.0.1"

def is_valid_ip(ip_string):
    try:
        parts = ip_string.split('.')
        if len(parts) != 4: return False
        for part in parts:
            num = int(part)
            if num < 0 or num > 255: return False
        return True
    except:
        return False

# ================= NETWORK CLASS =================
# Az üzenetek egy QUEUE-ba kerülnek → a main thread olvasja őket.
# Ez megoldja a "start signal overírás" problémát.

class NetworkManager:
    def __init__(self):
        self.socket = None
        self.connected = False
        self.is_host = False
        self.client_socket = None
        self.running = False
        self.connection_error = None
        # Thread-safe üzenet queue
        self.message_queue = []
        self.queue_lock = threading.Lock()

    def host_game(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.socket.bind((HOST, PORT))
            self.socket.listen(1)
            self.is_host = True
            self.running = True
            threading.Thread(target=self._wait_for_connection, daemon=True).start()
            return True
        except Exception as e:
            self.connection_error = str(e)
            return False

    def _wait_for_connection(self):
        try:
            self.socket.settimeout(None)
            self.client_socket, addr = self.socket.accept()
            self.connected = True
            print(f"Client connected: {addr}")
            threading.Thread(target=self._receive_loop, daemon=True).start()
        except Exception as e:
            self.connection_error = str(e)

    def join_game(self, host_ip):
        if not is_valid_ip(host_ip):
            self.connection_error = "Wrong IP!"
            return False
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(5)
            self.socket.connect((host_ip, PORT))
            self.socket.settimeout(None)  # Csatlakozás után nincs timeout
            self.is_host = False
            self.connected = True
            self.running = True
            self.connection_error = None
            threading.Thread(target=self._receive_loop, daemon=True).start()
            return True
        except:
            self.connection_error = "Wrong IP!"
            return False

    # ── LENGTH-PREFIXED KÜLDÉS/FOGADÁS ──
    # Minden üzenetet 4 byte-os méret-prefix-szel küldünk.
    # Így nem fordul elő, hogy két üzenet összeolvad az TCP stream-ben.

    def _send_msg(self, sock, data):
        """Serialized data küldése length-prefix-szel"""
        payload = pickle.dumps(data)
        length = len(payload).to_bytes(4, 'big')
        sock.sendall(length + payload)

    def _recv_msg(self, sock):
        """Egy teljes üzenet fogadása length-prefix alapján"""
        # Először 4 byte-ot olvasunk (méret)
        raw_len = self._recv_exact(sock, 4)
        if raw_len is None:
            return None
        msg_len = int.from_bytes(raw_len, 'big')
        # Majd pontosan msg_len byte-ot olvasunk
        raw_data = self._recv_exact(sock, msg_len)
        if raw_data is None:
            return None
        return pickle.loads(raw_data)

    def _recv_exact(self, sock, n):
        """Pontosan n byte-ot olvasunk a socketből"""
        data = b''
        while len(data) < n:
            try:
                chunk = sock.recv(n - len(data))
                if not chunk:
                    return None
                data += chunk
            except:
                return None
        return data

    def _receive_loop(self):
        """Vételi loop — minden üzenet a queue-ba kerül"""
        sock = self.client_socket if self.is_host else self.socket
        while self.running and self.connected:
            msg = self._recv_msg(sock)
            if msg is None:
                self.connected = False
                break
            with self.queue_lock:
                self.message_queue.append(msg)

    def send_data(self, data):
        """Üzenet küldése"""
        if not self.connected:
            return
        try:
            sock = self.client_socket if self.is_host else self.socket
            self._send_msg(sock, data)
        except:
            self.connected = False

    def get_messages(self):
        """Main thread-ből hívva: összes érkezett üzenet levonja a queue-ból"""
        with self.queue_lock:
            msgs = list(self.message_queue)
            self.message_queue.clear()
        return msgs

    def close(self):
        self.running = False
        self.connected = False
        try:
            if self.client_socket: self.client_socket.close()
            if self.socket: self.socket.close()
        except: pass
        self.message_queue.clear()

# ================= PLAYER =================
class Player:
    def __init__(self, x=150, player_skin=0):
        self.size = 35
        self.x = x
        self.y = GROUND_Y - self.size
        self.vy = 0
        self.can_jump = True
        self.rot = 0
        self.trail = []
        self.dead = False
        self.jump_cooldown = 0
        self.skin = player_skin

    def jump(self):
        if self.can_jump and self.jump_cooldown <= 0:
            self.vy = JUMP
            self.can_jump = False
            self.jump_cooldown = 8
            play_jump_sound()

    def update(self, obstacles):
        if self.dead: return
        if self.jump_cooldown > 0:
            self.jump_cooldown -= 1

        old_y = self.y
        old_x = self.x

        self.vy += GRAVITY
        self.y += self.vy

        if self.y >= GROUND_Y - self.size:
            self.y = GROUND_Y - self.size
            self.vy = 0
            self.can_jump = True
            self.rot = 0
        else:
            self.rot += 10

        for o in obstacles:
            if o.type in ["block", "moving_block", "narrow_block", "gap_block"]:
                h_overlap = (self.x + self.size > o.x) and (self.x < o.x + o.w)
                v_overlap = (self.y + self.size > o.y) and (self.y < o.y + o.h)

                if h_overlap and v_overlap:
                    if self.vy > 0 and old_y + self.size <= o.y + 5:
                        self.y = o.y - self.size
                        self.vy = 0
                        self.can_jump = True
                        self.rot = 0
                    elif self.vy < 0 and old_y >= o.y + o.h - 5:
                        self.dead = True
                    elif old_x + self.size <= o.x + 5 or old_x >= o.x + o.w - 5:
                        self.dead = True
                    else:
                        self.dead = True

        self.trail.append((self.x, self.y))
        if len(self.trail) > 15:
            self.trail.pop(0)

    def draw(self, is_other=False):
        for i, pos in enumerate(self.trail):
            alpha = int(i * 12)
            surf = pygame.Surface((self.size, self.size), pygame.SRCALPHA)
            pygame.draw.rect(surf, SKINS[self.skin], (0, 0, self.size, self.size))
            surf.set_alpha(alpha)
            screen.blit(surf, pos)

        surf = pygame.Surface((self.size, self.size), pygame.SRCALPHA)
        pygame.draw.rect(surf, SKINS[self.skin], (0, 0, self.size, self.size))
        border = CYAN if is_other else WHITE
        pygame.draw.rect(surf, border, (0, 0, self.size, self.size), 2)

        rot = pygame.transform.rotate(surf, self.rot)
        rect = rot.get_rect(center=(self.x + self.size // 2, self.y + self.size // 2))
        screen.blit(rot, rect)

    def rect(self):
        return pygame.Rect(self.x, self.y, self.size, self.size)

    def get_data(self):
        return {
            'x': self.x, 'y': self.y, 'vy': self.vy,
            'rot': self.rot, 'dead': self.dead,
            'skin': self.skin, 'trail': self.trail[-5:]
        }

    def set_data(self, data):
        if data:
            self.x = data.get('x', self.x)
            self.y = data.get('y', self.y)
            self.vy = data.get('vy', self.vy)
            self.rot = data.get('rot', self.rot)
            self.dead = data.get('dead', self.dead)
            self.skin = data.get('skin', self.skin)
            if 'trail' in data: self.trail = data['trail']

# ================= OBSTACLE =================
class Obstacle:
    _next_id = 0  # Class variable for unique IDs
    
    def __init__(self, current_speed, obs_type=None, obs_h=None):
        self.id = Obstacle._next_id
        Obstacle._next_id += 1
        
        self.speed = current_speed

        if obs_type:
            self.type = obs_type
        else:
            rand = random.randint(1, 100)
            if rand <= 25: self.type = "spike"
            elif rand <= 45: self.type = "block"
            elif rand <= 60: self.type = "double_spike"
            elif rand <= 70: self.type = "moving_block"
            elif rand <= 80: self.type = "tall_spike"
            elif rand <= 90: self.type = "triple_spike"
            elif rand <= 95: self.type = "narrow_block"
            else: self.type = "gap_block"

        self.x = WIDTH

        if self.type == "spike":
            self.w = self.h = 35; self.color = RED; self.y = GROUND_Y - self.h
        elif self.type == "double_spike":
            self.w = 70; self.h = 35; self.color = RED; self.y = GROUND_Y - self.h
        elif self.type == "triple_spike":
            self.w = 105; self.h = 35; self.color = RED; self.y = GROUND_Y - self.h
        elif self.type == "tall_spike":
            self.w = 35; self.h = 60; self.color = ORANGE; self.y = GROUND_Y - self.h
        elif self.type == "block":
            self.w = 40
            self.h = obs_h if obs_h else random.choice([80, 120])
            self.color = PURPLE; self.y = GROUND_Y - self.h
        elif self.type == "narrow_block":
            self.w = 25; self.h = 100; self.color = PINK; self.y = GROUND_Y - self.h
        elif self.type == "gap_block":
            self.w = 40; self.h = 90; self.color = PURPLE
            self.y = GROUND_Y - self.h; self.gap_width = 80; self.has_second = True
        elif self.type == "moving_block":
            self.w = 40; self.h = 100; self.color = CYAN
            self.y = GROUND_Y - self.h; self.move_range = 80
            self.move_speed = 4; self.move_dir = 1; self.start_y = self.y

    def update(self):
        self.x -= self.speed
        if self.type == "moving_block":
            self.y += self.move_speed * self.move_dir
            if self.y <= self.start_y - self.move_range: self.move_dir = 1
            elif self.y >= self.start_y: self.move_dir = -1

    def draw(self):
        if self.type == "spike":
            pts = [(self.x+self.w//2, self.y), (self.x, self.y+self.h), (self.x+self.w, self.y+self.h)]
            pygame.draw.polygon(screen, self.color, pts)
            pygame.draw.polygon(screen, WHITE, pts, 2)
        elif self.type == "double_spike":
            for i in range(2):
                off = i*35
                pts = [(self.x+off+17, self.y), (self.x+off, self.y+self.h), (self.x+off+35, self.y+self.h)]
                pygame.draw.polygon(screen, self.color, pts)
                pygame.draw.polygon(screen, WHITE, pts, 2)
        elif self.type == "triple_spike":
            for i in range(3):
                off = i*35
                pts = [(self.x+off+17, self.y), (self.x+off, self.y+self.h), (self.x+off+35, self.y+self.h)]
                pygame.draw.polygon(screen, self.color, pts)
                pygame.draw.polygon(screen, WHITE, pts, 2)
        elif self.type == "tall_spike":
            pts = [(self.x+self.w//2, self.y), (self.x, self.y+self.h), (self.x+self.w, self.y+self.h)]
            pygame.draw.polygon(screen, self.color, pts)
            pygame.draw.polygon(screen, WHITE, pts, 2)
        elif self.type in ["block", "narrow_block"]:
            pygame.draw.rect(screen, self.color, (self.x, self.y, self.w, self.h))
            pygame.draw.line(screen, YELLOW, (self.x, self.y), (self.x+self.w, self.y), 4)
            pygame.draw.rect(screen, WHITE, (self.x, self.y, self.w, self.h), 2)
            if self.type == "narrow_block":
                pygame.draw.circle(screen, YELLOW, (int(self.x+self.w//2), int(self.y+self.h//2)), 3)
        elif self.type == "gap_block":
            pygame.draw.rect(screen, self.color, (self.x, self.y, self.w, self.h))
            pygame.draw.line(screen, YELLOW, (self.x, self.y), (self.x+self.w, self.y), 4)
            pygame.draw.rect(screen, WHITE, (self.x, self.y, self.w, self.h), 2)
            if self.has_second:
                x2 = self.x + self.w + self.gap_width
                pygame.draw.rect(screen, self.color, (x2, self.y, self.w, self.h))
                pygame.draw.line(screen, YELLOW, (x2, self.y), (x2+self.w, self.y), 4)
                pygame.draw.rect(screen, WHITE, (x2, self.y, self.w, self.h), 2)
        elif self.type == "moving_block":
            pygame.draw.rect(screen, self.color, (self.x, self.y, self.w, self.h))
            pygame.draw.line(screen, YELLOW, (self.x, self.y), (self.x+self.w, self.y), 4)
            pygame.draw.rect(screen, WHITE, (self.x, self.y, self.w, self.h), 2)
            pygame.draw.circle(screen, WHITE, (int(self.x+self.w//2), int(self.y+self.h//2)), 5)

    def rect(self):
        return pygame.Rect(self.x, self.y, self.w, self.h)

    def off(self):
        if self.type == "gap_block":
            return self.x + self.w + self.gap_width + self.w < 0
        return self.x + self.w < 0

# ================= GAME STATE =================
player = Player(player_skin=skin_index)
other_player = Player(x=150, player_skin=0)
obstacles = []
spawn = 0
score = 0
current_speed = BASE_SPEED
last_game_speed = BASE_SPEED
state = "menu"
network = NetworkManager()
multiplayer_mode = False
mp_result = None  # "win" / "lose" / None

font_big = pygame.font.Font(None, 80)
font_med = pygame.font.Font(None, 40)
font_small = pygame.font.Font(None, 30)
font_huge = pygame.font.Font(None, 120)

setting_selected = 0
input_text = ""
input_active = False
error_message = ""
error_message_timer = 0

# ================= FUNCTIONS =================
def reset():
    global player, other_player, obstacles, spawn, score, current_speed, mp_result
    player = Player(player_skin=skin_index)
    other_player = Player(x=150, player_skin=0)
    obstacles = []
    spawn = 0
    score = 0
    current_speed = BASE_SPEED
    mp_result = None

def parallax_bg():
    screen.fill((10, 10, 30))
    for s in stars:
        s[0] -= s[2] * (current_speed / BASE_SPEED)
        if s[0] < 0: s[0] = WIDTH
        pygame.draw.circle(screen, WHITE, (s[0], s[1]), s[2])

def draw_ground():
    pygame.draw.rect(screen, (40,40,40), (0, GROUND_Y, WIDTH, HEIGHT))
    pygame.draw.line(screen, YELLOW, (0, GROUND_Y), (WIDTH, GROUND_Y), 4)

def draw_skin_preview(x, y):
    pygame.draw.rect(screen, SKINS[skin_index], (x, y, 60, 60))
    pygame.draw.rect(screen, WHITE, (x, y, 60, 60), 3)

def draw_volume_bar(x, y, volume, selected=False):
    bw, bh = 300, 30
    fw = int(bw * volume)
    c = YELLOW if selected else GRAY
    pygame.draw.rect(screen, c, (x, y, bw, bh), 3)
    pygame.draw.rect(screen, GREEN, (x+2, y+2, max(0, fw-4), bh-4))
    screen.blit(font_small.render(f"{int(volume*100)}%", True, WHITE), (x+bw+20, y))

def draw_toggle(x, y, enabled, selected=False):
    bs = 30
    c = YELLOW if selected else GRAY
    pygame.draw.rect(screen, c, (x, y, bs, bs), 3)
    if enabled:
        pygame.draw.rect(screen, GREEN, (x+3, y+3, bs-6, bs-6))
    screen.blit(font_small.render("ON" if enabled else "OFF", True, WHITE), (x+bs+10, y))

def get_speed_color_for_value(sv):
    r = (sv - BASE_SPEED) / (MAX_SPEED - BASE_SPEED)
    if r < 0.33: return GREEN
    elif r < 0.66: return YELLOW
    else: return RED

def get_speed_color():
    return get_speed_color_for_value(current_speed)

def show_error(msg):
    global error_message, error_message_timer
    error_message = msg
    error_message_timer = 180

def trigger_game_over(result):
    """Game over trigger — MP eredményt beállítja"""
    global state, last_game_speed, max_speed_record, high_score, mp_result
    if mp_result is not None: return
    mp_result = result
    state = "over"
    pygame.mixer.music.stop()
    play_death_sound()
    last_game_speed = current_speed
    if current_speed > max_speed_record:
        max_speed_record = current_speed
    if score > high_score:
        high_score = score
    save_scores(high_score, max_speed_record)

# ================= START MENU MUSIC =================
play_menu_music()

# ================= MAIN LOOP =================
running = True
space_held = False

while running:
    clock.tick(FPS)

    if error_message_timer > 0:
        error_message_timer -= 1
        if error_message_timer == 0:
            error_message = ""

    # ================= NETWORK MESSAGE PROCESSING =================
    # Ez MINDIG fut — nem csak play state-ben! Így a "start" signal nem veszhet el.
    if multiplayer_mode and network.connected:
        messages = network.get_messages()
        for msg in messages:
            if not isinstance(msg, dict):
                continue

            msg_type = msg.get("type")

            # ── START signal (csak client fogadja) ──
            if msg_type == "start" and not network.is_host:
                if state == "waiting":
                    state = "play"
                    reset()
                    play_game_music()

            # ── GAME OVER signal ──
            elif msg_type == "game_over":
                result = msg.get("result")  # "win" oder "lose" — nekünk
                if result in ("win", "lose"):
                    trigger_game_over(result)

            # ── Player data ──
            elif msg_type == "player_data":
                if state == "play":
                    other_player.set_data(msg.get("data"))
                    
                    # CLIENT: fogadja a HOST obstacle adatait + score
                    if not network.is_host and "obstacles" in msg:
                        obstacles_data = msg["obstacles"]
                        
                        # ID-alapú szinkronizáció
                        existing_by_id = {o.id: o for o in obstacles if hasattr(o, 'id')}
                        
                        new_obstacles = []
                        
                        for obs_data in obstacles_data:
                            obs_id = obs_data["id"]
                            
                            if obs_id in existing_by_id:
                                # Update existing obstacle - pozíciók a HOST-tól
                                found = existing_by_id[obs_id]
                                found.x = obs_data["x"]
                                found.y = obs_data["y"]  # Existing obstacle-nál OK az y update
                                found.speed = obs_data["speed"]
                                
                                # Moving block mozgás állapot
                                if found.type == "moving_block":
                                    found.move_dir = obs_data.get("move_dir", found.move_dir)
                                
                                new_obstacles.append(found)
                            else:
                                # ÚJ obstacle: normál constructor inicializálja HELYESEN
                                new_obs = Obstacle(obs_data["speed"], obs_data["type"], obs_data.get("h"))
                                
                                # Felülírjuk az ID-t és CSAK az X pozíciót!
                                # Az Y-t a constructor már helyesen beállította (GROUND_Y - h)
                                new_obs.id = obs_id
                                new_obs.x = obs_data["x"]
                                # NEM írjuk felül az y-t! A constructor már jó értéket adott neki.
                                
                                # Moving block esetén mozgás állapot (de start_y már helyes)
                                if new_obs.type == "moving_block":
                                    # A HOST y pozíciója alapján számoljuk a move_dir-t
                                    # Ha HOST y > start_y → lefelé megy
                                    host_y = obs_data["y"]
                                    if abs(host_y - new_obs.start_y) > 5:
                                        # Van eltérés, szinkronizáljuk
                                        new_obs.y = host_y
                                        if host_y > new_obs.start_y + new_obs.move_range / 2:
                                            new_obs.move_dir = -1
                                        else:
                                            new_obs.move_dir = 1
                                
                                new_obstacles.append(new_obs)
                        
                        # Cseréljük le az obstacles listát
                        obstacles.clear()
                        obstacles.extend(new_obstacles)
                        
                        # Score és speed frissítés
                        if "score" in msg:
                            globals()["score"] = msg["score"]
                        if "current_speed" in msg:
                            globals()["current_speed"] = msg["current_speed"]

    # ================= EVENT HANDLING =================
    for e in pygame.event.get():
        if e.type == pygame.QUIT:
            running = False
            network.close()

        if e.type == pygame.KEYDOWN:
            # Input mező kezelés
            if input_active:
                if e.key == pygame.K_RETURN:
                    if input_text.strip():
                        if network.join_game(input_text.strip()):
                            multiplayer_mode = True
                            state = "waiting"
                            error_message = ""
                        else:
                            show_error(network.connection_error or "Wrong IP!")
                            input_text = ""
                    input_active = False
                elif e.key == pygame.K_BACKSPACE:
                    input_text = input_text[:-1]
                elif e.key == pygame.K_ESCAPE:
                    input_active = False
                    input_text = ""
                elif len(input_text) < 15 and e.unicode.isprintable():
                    input_text += e.unicode
                continue

            if e.key == pygame.K_ESCAPE:
                if state == "menu": running = False
                elif state in ["play", "over"]:
                    state = "menu"
                    play_menu_music()
                    if multiplayer_mode:
                        network.close()
                        multiplayer_mode = False
                elif state == "settings": state = "menu"
                elif state in ["multiplayer_menu", "waiting"]:
                    state = "menu"
                    network.close()
                    multiplayer_mode = False
                    error_message = ""

            # SPACE
            if e.key == pygame.K_SPACE:
                space_held = True

                if state == "menu":
                    state = "play"
                    reset()
                    play_game_music()

                elif state == "play":
                    player.jump()

                elif state == "over":
                    if multiplayer_mode:
                        state = "menu"
                        play_menu_music()
                        network.close()
                        multiplayer_mode = False
                    else:
                        state = "play"
                        reset()
                        play_game_music()

                # Waiting: csak HOST indíthat
                elif state == "waiting":
                    if network.is_host and network.connected:
                        network.send_data({"type": "start"})
                        state = "play"
                        reset()
                        play_game_music()
                    # Client: semmi sem történik

            if e.key == pygame.K_s and state == "menu":
                state = "settings"
                setting_selected = 0

            if e.key == pygame.K_m and state == "menu":
                state = "multiplayer_menu"
                error_message = ""

            # Settings
            if state == "settings":
                if e.key == pygame.K_UP: setting_selected = (setting_selected-1) % 4
                elif e.key == pygame.K_DOWN: setting_selected = (setting_selected+1) % 4

                if setting_selected == 0 and e.key in [pygame.K_LEFT, pygame.K_RIGHT]:
                    skin_index = (skin_index + (1 if e.key == pygame.K_RIGHT else -1)) % len(SKINS)
                    player.skin = skin_index
                    save_current_settings()
                if setting_selected == 1:
                    if e.key == pygame.K_LEFT:
                        music_volume = max(0, music_volume-0.1); update_music_volume(); save_current_settings()
                    elif e.key == pygame.K_RIGHT:
                        music_volume = min(1.0, music_volume+0.1); update_music_volume(); save_current_settings()
                if setting_selected == 2:
                    if e.key == pygame.K_LEFT:
                        sfx_volume = max(0, sfx_volume-0.1); update_sfx_volume(); save_current_settings()
                    elif e.key == pygame.K_RIGHT:
                        sfx_volume = min(1.0, sfx_volume+0.1); update_sfx_volume(); save_current_settings()
                if setting_selected == 3 and e.key in [pygame.K_LEFT, pygame.K_RIGHT, pygame.K_RETURN]:
                    toggle_fullscreen()

            # Multiplayer menu
            if state == "multiplayer_menu":
                if e.key == pygame.K_h:
                    if network.host_game():
                        multiplayer_mode = True
                        state = "waiting"
                    else:
                        show_error("Failed to host!")
                if e.key == pygame.K_j:
                    input_active = True
                    input_text = ""

        if e.type == pygame.KEYUP:
            if e.key == pygame.K_SPACE:
                space_held = False

    # ================= CONTINUOUS JUMP =================
    if state == "play" and space_held:
        player.jump()

    # ================= SEND OWN PLAYER DATA + OBSTACLES =================
    if multiplayer_mode and network.connected and state == "play":
        msg = {"type": "player_data", "data": player.get_data()}
        
        # HOST küldi az obstacle adatokat + score
        if network.is_host:
            obstacles_data = []
            for o in obstacles:
                obs = {
                    "id": o.id,
                    "type": o.type,
                    "x": o.x,
                    "y": o.y,
                    "w": o.w,
                    "h": o.h,
                    "speed": o.speed,
                    "color": o.color
                }
                # Moving block extra adatok
                if o.type == "moving_block":
                    obs["start_y"] = o.start_y
                    obs["move_range"] = o.move_range
                    obs["move_speed"] = o.move_speed
                    obs["move_dir"] = o.move_dir
                # Gap block extra adatok
                elif o.type == "gap_block":
                    obs["gap_width"] = o.gap_width
                    obs["has_second"] = o.has_second
                
                obstacles_data.append(obs)
            msg["obstacles"] = obstacles_data
            msg["score"] = score
            msg["current_speed"] = current_speed
        
        network.send_data(msg)

    # ================= GAME LOGIC =================
    if state == "play":
        current_speed = min(MAX_SPEED, BASE_SPEED + (score * SPEED_INCREASE_RATE))

        player.update(obstacles)

        if multiplayer_mode and network.connected:
            other_player.update(obstacles)

            # Spike collision — SAJÁT
            for o in obstacles:
                if o.type in ["spike","double_spike","tall_spike","triple_spike"]:
                    if not player.dead and player.rect().colliderect(o.rect()):
                        player.dead = True

            # Spike collision — MÁSIK (csak HOST ellenőrzi, hogy ne duplikálódjon)
            if network.is_host:
                for o in obstacles:
                    if o.type in ["spike","double_spike","tall_spike","triple_spike"]:
                        if not other_player.dead and other_player.rect().colliderect(o.rect()):
                            other_player.dead = True

            # Ha SAJÁT meghalt → mi vesztettünk
            if player.dead and mp_result is None:
                trigger_game_over("lose")
                # Mondjuk a másiknak: ő nyert
                network.send_data({"type": "game_over", "result": "win"})

            # Ha MÁSIK meghalt → mi nyertünk (csak HOST detektálja)
            if network.is_host and other_player.dead and mp_result is None:
                trigger_game_over("win")
                # Mondjuk a client-nek: ő veszett
                network.send_data({"type": "game_over", "result": "lose"})

        else:
            # ── SINGLEPLAYER ──
            for o in obstacles:
                if o.type in ["spike","double_spike","tall_spike","triple_spike"]:
                    if player.rect().colliderect(o.rect()):
                        player.dead = True

            if player.dead:
                state = "over"
                pygame.mixer.music.stop()
                play_death_sound()
                last_game_speed = current_speed
                if current_speed > max_speed_record: max_speed_record = current_speed
                if score > high_score: high_score = score
                save_scores(high_score, max_speed_record)

        # Obstacle spawn
        if not multiplayer_mode:
            # SINGLEPLAYER
            spawn += 1
            spawn_rate = max(40, 70 - int(score * 0.5))
            if spawn > spawn_rate:
                obstacles.append(Obstacle(current_speed))
                spawn = 0
        elif network.is_host:
            # MULTIPLAYER HOST
            spawn += 1
            spawn_rate = max(40, 70 - int(score * 0.5))
            if spawn > spawn_rate:
                obstacles.append(Obstacle(current_speed))
                spawn = 0

        # Obstacle update + score
        if not multiplayer_mode:
            # SINGLEPLAYER
            for o in obstacles[:]:
                o.update()
                if o.off():
                    obstacles.remove(o)
                    score += 1
                    play_score_sound()
        elif network.is_host:
            # MULTIPLAYER HOST
            for o in obstacles[:]:
                o.update()
                if o.off():
                    obstacles.remove(o)
                    score += 1
                    play_score_sound()
        # MULTIPLAYER CLIENT: NEM futtat obstacle.update()-et!
        # Minden pozíciót a HOST-tól kap, csak rajzolja őket

    # ================= DRAW =================
    parallax_bg()
    draw_ground()

    if state == "menu":
        t = font_big.render("GEOMETRY DASH PRO", True, BLUE)
        screen.blit(t, (WIDTH//2 - t.get_width()//2, 80))
        screen.blit(font_med.render("SPACE = PLAY", True, WHITE), (WIDTH//2-150, 200))
        screen.blit(font_med.render("M = MULTIPLAYER", True, CYAN), (WIDTH//2-150, 240))
        screen.blit(font_med.render("S = SETTINGS", True, WHITE), (WIDTH//2-150, 280))
        screen.blit(font_med.render("ESC = EXIT", True, WHITE), (WIDTH//2-150, 320))
        screen.blit(font_med.render(f"High Score: {high_score}", True, YELLOW), (WIDTH//2-150, 370))
        screen.blit(font_med.render(f"Max Speed: {max_speed_record:.1f}", True, get_speed_color_for_value(max_speed_record)), (WIDTH//2-150, 410))
        screen.blit(font_med.render("Current Skin:", True, WHITE), (WIDTH//2-150, 460))
        draw_skin_preview(WIDTH//2+50, 450)
        screen.blit(font_small.render("TIP: Hold SPACE for continuous jumps!", True, CYAN), (WIDTH//2-200, HEIGHT-60))

    elif state == "multiplayer_menu":
        screen.blit(font_big.render("MULTIPLAYER", True, CYAN), (WIDTH//2-180, 100))
        screen.blit(font_med.render(f"Your IP: {get_local_ip()}", True, YELLOW), (WIDTH//2-150, 200))
        screen.blit(font_med.render("H = HOST GAME", True, GREEN), (WIDTH//2-150, 280))
        screen.blit(font_med.render("J = JOIN GAME", True, GREEN), (WIDTH//2-150, 320))
        screen.blit(font_med.render("ESC = BACK", True, WHITE), (WIDTH//2-150, 360))
        screen.blit(font_small.render("Both players must be on the same WiFi!", True, WHITE), (WIDTH//2-220, 420))

        if error_message:
            es = font_med.render(error_message, True, RED)
            screen.blit(es, (WIDTH//2 - es.get_width()//2, 500))

        if input_active:
            pygame.draw.rect(screen, YELLOW, (WIDTH//2-150, 460, 300, 40), 3)
            screen.blit(font_small.render(input_text, True, WHITE), (WIDTH//2-140, 470))
            screen.blit(font_small.render("Enter host IP + ENTER:", True, GRAY), (WIDTH//2-170, 440))

    elif state == "waiting":
        screen.blit(font_big.render("WAITING...", True, YELLOW), (WIDTH//2-180, 180))

        if network.is_host:
            screen.blit(font_med.render("Waiting for player...", True, WHITE), (WIDTH//2-200, 260))
            screen.blit(font_small.render(f"Your IP: {get_local_ip()}", True, CYAN), (WIDTH//2-120, 300))
            if network.connected:
                screen.blit(font_med.render("Player connected!", True, GREEN), (WIDTH//2-180, 350))
                screen.blit(font_med.render("SPACE = Start Game", True, YELLOW), (WIDTH//2-180, 400))
            else:
                screen.blit(font_small.render("(Waiting for someone to join...)", True, GRAY), (WIDTH//2-200, 360))
        else:
            # CLIENT
            if network.connected:
                screen.blit(font_med.render("Connected!", True, GREEN), (WIDTH//2-150, 280))
                screen.blit(font_med.render("Waiting for host to start...", True, WHITE), (WIDTH//2-240, 330))
            else:
                screen.blit(font_med.render("Connecting...", True, WHITE), (WIDTH//2-150, 280))

        screen.blit(font_med.render("ESC = CANCEL", True, WHITE), (WIDTH//2-150, HEIGHT-100))

    elif state == "settings":
        screen.blit(font_big.render("SETTINGS", True, GREEN), (WIDTH//2-150, 60))
        ys = 160
        screen.blit(font_med.render("< Skin >", True, YELLOW if setting_selected==0 else WHITE), (WIDTH//2-200, ys))
        draw_skin_preview(WIDTH//2+100, ys-5)
        ys += 80
        screen.blit(font_med.render("Music Volume:", True, YELLOW if setting_selected==1 else WHITE), (WIDTH//2-200, ys))
        draw_volume_bar(WIDTH//2-200, ys+40, music_volume, setting_selected==1)
        ys += 120
        screen.blit(font_med.render("SFX Volume:", True, YELLOW if setting_selected==2 else WHITE), (WIDTH//2-200, ys))
        draw_volume_bar(WIDTH//2-200, ys+40, sfx_volume, setting_selected==2)
        ys += 120
        screen.blit(font_med.render("Fullscreen:", True, YELLOW if setting_selected==3 else WHITE), (WIDTH//2-200, ys))
        draw_toggle(WIDTH//2-200, ys+40, fullscreen_enabled, setting_selected==3)
        screen.blit(font_small.render("UP/DOWN = Navigate", True, WHITE), (WIDTH//2-150, HEIGHT-150))
        screen.blit(font_small.render("LEFT/RIGHT = Adjust", True, WHITE), (WIDTH//2-150, HEIGHT-120))
        screen.blit(font_small.render("ESC = Back", True, WHITE), (WIDTH//2-150, HEIGHT-90))
        screen.blit(font_small.render("Settings are auto-saved", True, GREEN), (WIDTH//2-130, HEIGHT-50))

    elif state == "play":
        for o in obstacles: o.draw()
        if multiplayer_mode and network.connected:
            other_player.draw(is_other=True)
        player.draw()

        screen.blit(font_med.render(f"Score: {score}", True, WHITE), (10, 10))
        sc = get_speed_color()
        screen.blit(font_small.render(f"Speed: {current_speed:.1f}", True, sc), (10, 50))

        bw, bh, bx, by = 200, 10, 10, 85
        sr = (current_speed - BASE_SPEED) / (MAX_SPEED - BASE_SPEED)
        pygame.draw.rect(screen, GRAY, (bx, by, bw, bh), 2)
        pygame.draw.rect(screen, sc, (bx, by, int(bw*sr), bh))

        if multiplayer_mode and network.connected:
            screen.blit(font_small.render("MULTIPLAYER MODE", True, CYAN), (WIDTH-220, 10))
            role = "HOST" if network.is_host else "CLIENT"
            screen.blit(font_small.render(role, True, YELLOW), (WIDTH-220, 35))

    elif state == "over":
        # Sötét overlay
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 160))
        screen.blit(overlay, (0, 0))

        if multiplayer_mode:
            # ── MULTIPLAYER GAME OVER ──
            if mp_result == "win":
                txt = font_huge.render("YOU WIN!", True, GREEN)
                screen.blit(txt, (WIDTH//2 - txt.get_width()//2, 100))
                pygame.draw.rect(screen, GREEN, (40, 80, WIDTH-80, 160), 4)
            elif mp_result == "lose":
                txt = font_huge.render("YOU LOSE!", True, RED)
                screen.blit(txt, (WIDTH//2 - txt.get_width()//2, 100))
                pygame.draw.rect(screen, RED, (40, 80, WIDTH-80, 160), 4)

            screen.blit(font_med.render(f"Score: {score}", True, WHITE), (WIDTH//2-100, 280))
            sc = get_speed_color_for_value(last_game_speed)
            screen.blit(font_small.render(f"Speed Reached: {last_game_speed:.1f}", True, sc), (WIDTH//2-150, 320))
            screen.blit(font_med.render("SPACE = Back to Menu", True, WHITE), (WIDTH//2-180, 400))
            screen.blit(font_med.render("ESC = Exit", True, WHITE), (WIDTH//2-100, 440))
        else:
            # ── SINGLEPLAYER GAME OVER ──
            screen.blit(font_big.render("GAME OVER", True, RED), (WIDTH//2-200, 120))
            screen.blit(font_med.render(f"Final Score: {score}", True, WHITE), (WIDTH//2-150, 220))
            sc = get_speed_color_for_value(last_game_speed)
            screen.blit(font_small.render(f"Speed Reached: {last_game_speed:.1f}", True, sc), (WIDTH//2-150, 260))

            if score == high_score and score > 0:
                screen.blit(font_med.render("NEW HIGH SCORE!", True, YELLOW), (WIDTH//2-180, 300))
            if last_game_speed >= max_speed_record and last_game_speed > BASE_SPEED:
                screen.blit(font_small.render("NEW MAX SPEED RECORD!", True, CYAN), (WIDTH//2-170, 340))
            else:
                screen.blit(font_small.render(f"Best Speed: {max_speed_record:.1f}", True, GRAY), (WIDTH//2-130, 340))

            screen.blit(font_med.render("SPACE = Restart", True, WHITE), (WIDTH//2-150, 400))
            screen.blit(font_med.render("ESC = Menu", True, WHITE), (WIDTH//2-100, 440))

    pygame.display.flip()

network.close()
pygame.quit()
sys.exit()
